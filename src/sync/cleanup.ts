import { join, normalize } from 'path';
import type { EditorAdapter, SyncResult, OrphanedFile } from '../core/types.js';
import { AUTO_GENERATED_MARKER } from '../core/types.js';
import { findMarkdownFiles, removeFile } from '../utils/file-ops.js';
import { log } from '../utils/logger.js';

export async function detectOrphans(
  projectRoot: string,
  adapters: EditorAdapter[],
  result: SyncResult,
): Promise<OrphanedFile[]> {
  const orphans: OrphanedFile[] = [];

  // Build a Set of normalized synced paths for robust comparison
  const syncedPaths = new Set(result.synced.map((p) => normalize(p)));

  // Collect all unique directories across all adapters to avoid scanning the same dir twice
  const allDirs = new Set<string>();
  for (const adapter of adapters) {
    const dirs = [
      adapter.directories.rules,
      adapter.directories.skills,
      adapter.directories.workflows,
    ].filter(Boolean) as string[];
    for (const dir of dirs) {
      allDirs.add(dir);
    }
  }

  for (const dir of allDirs) {
    const fullDir = join(projectRoot, dir);
    const files = await findMarkdownFiles(fullDir, fullDir);

    for (const file of files) {
      // Only flag files that were auto-generated by ai-toolkit
      if (file.content.includes(AUTO_GENERATED_MARKER)) {
        // Check if this file is in the current sync result
        const fullPath = normalize(file.absolutePath);
        if (!syncedPaths.has(fullPath)) {
          orphans.push({
            relativePath: join(dir, file.relativePath),
            absolutePath: fullPath,
          });
        }
      }
    }
  }

  return orphans;
}

export async function removeOrphanFile(orphan: OrphanedFile): Promise<boolean> {
  const success = await removeFile(orphan.absolutePath);
  if (success) {
    log.removed(orphan.relativePath);
  }
  return success;
}
